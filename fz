#!/bin/python3

import sys
import os
import subprocess
import configparser


HOME = os.environ["HOME"]
COPY_CMD = "wl-copy"

# helpers


def parse_conf():
    config = configparser.ConfigParser()
    config.read(os.path.join(HOME, ".scripts", "bin", "fz.ini"))

    SSHFS = {}
    for k, v in config["SSHFS"].items():
        SSHFS[k] = k.split(" ")[1] + " " + v
    return SSHFS


glob_ssfs_lookup = parse_conf()


def call_fzf(lin: str, **kwargs):
    args = ["fzf"]
    for k, v in kwargs.items():
        args.append("--" + k)
        args.append(v)
    if "height" not in kwargs:
        args.append("--height")
        args.append("50%")
    if "border" not in kwargs:
        args.append("--border")
    if "reverse" not in kwargs:
        args.append("--reverse")

    p = subprocess.Popen(args, stdin=subprocess.PIPE, stdout=subprocess.PIPE)
    out, _ = p.communicate(lin.encode())
    return out.decode().strip()


def notify(msg: str):
    dunst = subprocess.run(
        ["notify-send", "-h", "string:bgcolor:#2e3440",
         "-h", "string:fgcolor:#d8dee9 ", msg])
    return dunst.returncode

# The command handlers


def bt():
    devices = subprocess.run(["bluetoothctl", "devices"],
                             stdout=subprocess.PIPE).stdout.decode().splitlines()
    devices = [x.split() for x in devices]
    names = [" ".join(x[2:]) for x in devices]
    ids = [x[1] for x in devices]
    choice = call_fzf("\n".join(names), prompt="Select a device: ")

    if choice == "":
        return

    code = subprocess.run(
        ["bluetoothctl", "connect", ids[names.index(choice)]])
    if code.returncode == 0:
        notify("Bluetooth connected to " + choice)
    else:
        notify("Bluetooth connection failed")
    return


def ubt():
    devices = subprocess.run(["bluetoothctl", "devices"],
                             stdout=subprocess.PIPE)
    devices = devices.stdout.decode().splitlines()
    devices = [x.split() for x in devices]
    names = [" ".join(x[2:]) for x in devices]
    ids = [x[1] for x in devices]
    choice = call_fzf("\n".join(names), prompt="Select a device: ")

    if choice == "":
        return

    subprocess.run(["bluetoothctl", "disconnect", ids[names.index(choice)]])
    notify("Bluetooth disconnected from " + choice)
    return


def bg():
    picdir = "/home/abdullah/Pictures/Wallpapers"
    pics = os.listdir(picdir)
    choice = call_fzf("random\n"+"\n".join(pics),
                      prompt="Select a background: ",
                      preview="swaymsg output '*' \
                              bg " + picdir + "/{} fill",

                      **{"preview-window": "0%"})
    if choice == "":
        return

    # Using sway on Wayland
    if choice == "random":
        notify("Setting background to a random picture")
        os.system("swaymsg output '*' bg " + picdir + "/$(ls "
                  + picdir + "| shuf -n 1) fill")

    else:
        notify("Setting background to " + choice)
        # The preview window does the job
        return


base_lsblk = [
    "nvme0n1", "nvme0n1p1", "nvme0n1p2", "nvme0n1p3", "nvme0n1p4",
    "nvme0n1p5", "nvme0n1p6", "nvme0n2", "nvme0n3"]


def mount():
    p1 = subprocess.Popen(["lsblk", "-l"], stdout=subprocess.PIPE)
    p2 = subprocess.Popen(["grep", "-E", "part"], stdin=p1.stdout,
                          stdout=subprocess.PIPE)
    p3 = subprocess.Popen(["awk", "{print $1}"], stdin=p2.stdout,
                          stdout=subprocess.PIPE)
    if p1.stdout:
        p1.stdout.close()
    if p2.stdout:
        p2.stdout.close()
    out, _ = p3.communicate()
    points = filter(lambda x: x not in base_lsblk, out.decode().splitlines())
    choice = call_fzf("\n".join(points), prompt="Select a mount point: ")

    if choice == "":
        return

    mount_dir = HOME + "/mounts/" + choice

    os.system("mkdir -p " + mount_dir)

    subprocess.run(["sudo", "mount", "/dev/" + choice, mount_dir,
                    "-o", "uid=abdullah,gid=abdullah"])
    notify("Mounted " + choice + " to " + mount_dir)
    return


def umount():
    p1 = subprocess.Popen(["lsblk", "-l"], stdout=subprocess.PIPE)
    p2 = subprocess.Popen(["grep", "-e", "part"], stdin=p1.stdout,
                          stdout=subprocess.PIPE)
    p3 = subprocess.Popen(["awk", "{print $1,$7}"], stdin=p2.stdout,
                          stdout=subprocess.PIPE)

    if p1.stdout:
        p1.stdout.close()
    if p2.stdout:
        p2.stdout.close()
    out, _ = p3.communicate()
    points = filter(lambda x: x.split()[
                    0] not in base_lsblk, out.decode().splitlines())
    choice = call_fzf("\n".join(points), prompt="Select a mount point: ")

    if choice == "":
        return

    name, mount_dir = choice.split()

    subprocess.run(["sudo", "umount", mount_dir])
    notify("Unmounted " + name + " from " + mount_dir)
    return


def display():
    print("display is not implemented yet")
    return


def eth():
    ret = subprocess.run(["sudo", "ifplugd"])
    if ret.returncode == 0:
        notify("Ethernet cable plugged in")
    return


def fs():
    filesys = []
    mounted_systems = subprocess.run(["cat", "/etc/mtab"],
                                     stdout=subprocess.PIPE)
    mounted_ = []
    for line in mounted_systems.stdout.decode().splitlines():
        if "sshfs" in line:
            mounted_.append(line.split(":")[-1].split()[0])

    for key, val in glob_ssfs_lookup.items():
        if val.split()[1] not in mounted_:
            filesys.append(key)

    choice = call_fzf("\n".join(filesys), prompt="Select a filesystem: ")

    if choice == "":
        return

    fs_cmd = glob_ssfs_lookup[choice].split(" ")

    # fs_cmd: username@host remote_dir local_dir password

    os.system("mkdir -p " + fs_cmd[2])
    os.system("echo " + fs_cmd[3] + " | " + COPY_CMD)
    os.system("sshfs " + fs_cmd[0] + ":" + fs_cmd[1] + " " + fs_cmd[2])

    notify("Mounted " + choice + " to " + fs_cmd[2])

    return


def ufs():
    filesys = []
    mounted_systems = subprocess.run(["cat", "/etc/mtab"],
                                     stdout=subprocess.PIPE)

    mounted_ = []
    for line in mounted_systems.stdout.decode().splitlines():
        if "sshfs" in line:
            mounted_.append(line.split(":")[-1].split()[0])

    for key, val in glob_ssfs_lookup.items():
        if val.split()[1] in mounted_:
            filesys.append(key)

    choice = call_fzf("\n".join(filesys), prompt="Select a filesystem: ")

    if choice == "":
        return

    fs_cmd = glob_ssfs_lookup[choice].split(" ")

    os.system("fusermount -u " + fs_cmd[2])

    notify("Unmounted " + choice + " from " + fs_cmd[2])

    return


def ssh():
    hosts = {}
    host_to_name = {}
    for key, val in glob_ssfs_lookup.items():
        pswd = val.split()[-1]
        name, host = key.split(" ")
        hosts[(name, host)] = pswd
        host_to_name[host] = name

    choice = call_fzf("\n".join(glob_ssfs_lookup.keys()),
                      prompt="Select a host: ")

    if choice == "":
        return
    choice = tuple(choice.split(" "))

    notify("Connected to " + host_to_name[choice[1]])
    os.system("echo " + hosts[choice] + " | " + COPY_CMD)
    os.system("ssh " + choice[1] + " -t zsh")
    return


def ytfzf():
    subprocess.run(["ytfzf"])
    return


bg_tags = ["bg", "background", "image", "wallpaper", "Picture", "Pictures",
           "pic", "pics", "image", "images"]
mount_tags = ["mount", "mountp", "usb", "drive", "drives", "cd", "CD", "dvd",
              "DVD", "flash", "flashdrive", "flashdrives", "memory", "stick",
              "thumbdrive", "thunderbolt"]
umount_tags = ["umount", "unmount", "unmountp", "remove", "eject", "unplug",
               "unplugp"]
display_tags = ["display", "monitor", "screen", "screens", "multi", "dual",
                "dualscreen", "dualscreens", "mirror", "extend", "extendscreen"
                ]
eth_tags = ["ethernet", "eth", "network", "networks", "wifi", "wifis",
            "wlan", "wlans", "lan", "lans", "wireless", "connect",
            "connected", "connection", "connections"]
remote_fs_tags = ["remote", "remotefs", "remotefilesystem",
                  "remotefilesystems", "remote_fs", "remote_fs",
                  "remote_filesystem", "remote_filesystems", "fileserve", "fs"]
unremote_fs_tags = ["unremote", "unremotefs", "unremotefilesystems",
                    "unremote_fs", "unremote_fs", "removefilesystem",
                    "disconnect", "ufs", "unfs"]
bt_tags = ["bluetooth", "bt"]
unbt_tags = ["unbluetooth", "ubt", "unbt"]
ssh_tags = ["ssh", "remoteshell" "shell"]
ytfzf_tags = ["ytfzf", "youtube", "yt", "video", "videos", "music", "song"]


tags = [
    bg_tags, mount_tags, umount_tags, display_tags, eth_tags,
    remote_fs_tags, unremote_fs_tags, bt_tags, unbt_tags, ssh_tags,
    ytfzf_tags
]
tags_fun = [bg, mount, umount, display, eth, fs, ufs, bt, ubt, ssh, ytfzf]

assert len(tags) == len(tags_fun)


def fz():
    choice = call_fzf("\n".join([", ".join(x) for x in tags]),
                      prompt="Select a tag: ")

    if choice == "":
        return

    index = tags.index(choice.split(", "))
    tags_fun[index]()
    return


def print_usage():
    print("Usage: fz [option]")
    print("Options: ")
    print("  fz      - run fz again, but this time use fzf to select the option")
    print("  bg      - select a background, then set it, the input files are from ~/Pictures")
    print("  mount   - select a mount point, then mount it")
    print("  umount  - select a mount point, then unmount it")
    print("  ssh     - select a host, then ssh into it")
    print("  disp    - select a monitor using randr, then ask where to display it")
    print("  eth     - run ifplugd to connect to the internet")
    print("  fs      - select a filesystem, particulary remote, then mount it")
    print("  ufs     - select a filesystem, particulary remote, then unmount it")
    print("  bt      - select a bluetooth device, then connect to it")
    print("  ubt     - select a bluetooth device, then disconnect from it")
    print("  ytfzf   - search youtube for a video, then play it using mpv")
    print("  help    - print this help message")


def main():
    if len(sys.argv) == 1:
        print_usage()
        sys.exit(0)
    match sys.argv[1]:
        case  "fz" | "fzf":
            fz()
        case "bg":
            bg()
        case "m" | "mnt" | "mount":
            mount()
        case "um" | "umnt" | "umount":
            umount()
        case "d" | "disp" | "display":
            display()
        case "e" | "eth" | "ethernet":
            eth()
        case "f" | "fs" | "remotefs":
            fs()
        case "uf" | "ufs" | "unmountfs" | "unfs":
            ufs()
        case "h" | "help":
            print_usage()
        case "b" | "bt":
            bt()
        case "ubt":
            ubt()
        case "ssh":
            ssh()
        case "yt" | "ytfzf":
            ytfzf()
        case _:
            print_usage()
            sys.exit(0)


if __name__ == "__main__":
    main()
